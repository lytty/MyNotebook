# 持久化 - pickle
- 序列化（持久化，落地）：把程序运行中的信息保存到磁盘上
- 反序列化： 序列化的逆过程
- pickle：python提供的的序列化模块
- pickle.dump: 序列化
- pickle.load: 反序列化

# 持久化 - shelve
- 持久化工具
- 类似字典，用key-value对保存数据，存取方式跟字典也类似
- open， close
# shelve 特性
- 不支持多个应用并行写入
    - 为了解决这个问题，open的时候可以使用flag=r
- 写回问题
    - shelve写会情况下不会等待持久化对象进行任何修改
    - 解决方法：强制写回：writeback=True

# 多线程
- python2： thread， python3：_thread
- threading: 通行的包
- 守护线程：如果将线程设置为守护线程，守护线程会在主线程结束时自动退出
    - 一般认为守护线程不重要或者不允许离开主线程独立运行
- 共享变量
    - 共享变量： 当多个线程同时访问一个变量的时候，会产生共享变量的问题
    - 解决方法：锁，信号灯
    - 锁（Lock） threading.Lock()
- 线程安全问题：
    - 如果一个资源/变量，它对于多线程来讲，不用加锁也不会引起任何问题，则称为线程安全
    - 线程不安全变量类型： list， set， dict
    - 线程安全变量类型： queue
- 死锁问题
- 锁的等待时间问题
- semphore
- threading.Timer
    - Timer是利用多线程，在指定时间后启动一个功能
- 可重入锁
    - 一个锁，可以被一个线程多次申请
    - 主要解决递归调用的时候，需要申请锁的情况

# 线程替代方案
- subprocess
    - 完全跳过线程，使用进程
    - 是派生进程的主要替代方案
- multiprocessiong
- concurrent.futures
    - 新的异步执行模块
    - 任务级别的操作

# 多进程
- 进程间通信（IPC）
- 进程之间无任何共享状态
- 进程的创建

# 迭代
- 可迭代
- 迭代器
- 使用isinstance判断

# 生成器
- generator： 一边循环一边计算下一个元素的机制/算法
- 需满足三个条件：
    - 每次调用都生产出for循环的下一个元素
    - 如果达到最后一个后，爆出stopiteration异常
    - 可以被next函数调用
- 如何生成一个生成器
    - 直接使用
    - 如果函数中包含yield，则这个函数就叫生成器
    - next调用函数，遇到yield返回

# 协程
- 协程是为非抢占式多任务产生子程序的计算机组件，协程允许不同入口点在不同位置暂停或开始执行程序
- 从技术角度讲，协程就是一个你可以暂停执行的函数，或者可以直接理解为生成器
- 协程的实现：
    - yield返回
    - send调用
- 协程的四个状态
- 协程终止
    - 协程中未被处理的一场会向上冒泡，传给next函数或send方法的调用方（即触发协程的对象）
    - 止协程的一种方式：发送某个哨符值，让协程退出。内置的None和Elliosis等常量经常用作哨符值==
- yield from
    - 调用协程为了得到返回值，协程必须正常终止
    - 生成器正常终止会发出StopIteration异常，异常对象的value属性保存返回值
    - yield from从内部捕获Stop Iteration异常
    