# ARM汇编笔记



## ARM 内核SP，LR，PC寄存器

-   深入理解ARM的这三个寄存器，对编程以及操作系统的移植都有很大的裨益。

-   堆栈指针r13（SP）：每一种异常模式都有其自己独立的r13，它通常指向异常模式所专用的堆栈，也就是说五种异常模式、非异常模式（用户模式和系统模式），都有各自独立的堆栈，用不同的堆栈指针来索引。这样当ARM进入异常模式的时候，程序就可以把一般通用寄存器压入堆栈，返回时再出栈，保证了各种模式下程序的状态的完整性。

-   连接寄存器r14（LR）：每种模式下r14都有自身版组，它有两个特殊功能。

    -   保存子程序返回地址。使用BL或BLX时，跳转指令自动把返回地址放入r14中；子程序通过把r14复制到PC来实现返回，通常用下列指令之一：
                     MOV PC, LR 
                     BX LR

        通常子程序这样写，保证了子程序中还可以调用子程序。
                     stmfd sp!, {lr}
                     ……
                     ldmfd sp!, {pc}

    -   当异常发生时，异常模式的r14用来保存异常返回地址，将r14如栈可以处理嵌套中断。

-   程序计数器r15（PC）：PC是有读写限制的。当没有超过读取限制的时候，读取的值是指令的地址加上8个字节，由于ARM指令总是以字对齐的，故bit[1:0]总是00。当用str或stm存储PC的时候，偏移量有可能是8或12等其它值。在V3及以下版本中，写入bit[1:0]的值将被忽略，而在V4及以上版本写入r15的bit[1:0]必须为00，否则后果不可预测。



-   堆栈是一种具有“后进先出”（LIFO---Last In First Out）特殊访问属性的存储结构。堆栈一般使用RAM 物理资源作为存储体，再加上LIFO 访问接口实现。

​                  ![img](/home/haibin.xu/haibin/doc/picture/图 堆栈.png)



-   堆栈的实现方法：
    -   在随机存储器区划出一块区域作为堆栈区，数据可以一个个顺序地存入（压入）到这个区域之中，这个过程称为‘压栈’（push  ）。通常用一个指针（堆栈指针  SP---Stack Pointer）实现做一次调整，SP 总指向最后一个压入堆栈的数据所在的数据单元（栈顶）。从堆栈中读取数据时，按照堆栈 指针指向的堆栈单元读取堆栈数据，这个过程叫做 ‘弹出’（pop ），每弹出一个数据，SP 即向相反方向做一次调整，如此就实现了后进先出的原则。

    -   堆栈是计算机中广泛应用的技术，基于堆栈具有的数据进出LIFO特性，常应用于保存中断断点、保存子程序调用返回点、保存CPU现场数据等，也用于程序间传递参数。
    -   ARM处理器中通常将寄存器R13作为堆栈指针（SP）。**ARM处理器针对不同的模式，共有 6 个堆栈指针（SP），其中用户模式和系统模式共用一个SP，每种异常模式都有各自专用的R13寄存器（SP）。它们通常指向各模式所对应的专用堆栈，也就是ARM处理器允许用户程序有六个不同的堆栈空间。**这些堆栈指针分别为R13、R13_svc、R13_abt、R13_und、R13_irq、R13_fiq，如表2-3  堆栈指针寄存器所示。 ![img](/home/haibin.xu/haibin/doc/picture/图 堆栈指针寄存器.PNG)

    -   为了更准确地描述堆栈，根据“压栈”操作时堆栈指针的增减方向，将堆栈区分为‘递增堆栈’（SP 向大数值方向变化）和‘递减堆栈’（SP 向小数值方向变化）；又根据SP 指针指向的存储单元是否含有堆栈数据，又将堆栈区分为‘满堆栈’（SP 指向单元含有堆栈有效数据）和‘空堆栈’（SP 指向单元不含有堆栈有效数据）。这样两两组合共有四种堆栈方式——**满递增、空递增、满递减和空递减。** ARM处理器的堆栈操作具有非常大的灵活性，对这四种类型的堆栈都支持。**ARM处理器中的R13被用作SP。当不使用堆栈时，R13 也可以用做通用数据寄存器。**

## .globl _start

- `.globl`指示告诉汇编器，_start这个符号要被链接器用到，所以要在目标文件的符号表中标记它是一个全局符号。
- `_start`就像C程序的main函数一样特殊，是整个程序的入口，链接器在链接时会查找目标文件中的_start符号代表的地址，把它设置为整个程序的入口地址，所以每个汇编程序都要提供一个_start符号并且用.globl声明。如果一个符号没有用.globl声明，就表示这个符号不会被链接器用到。



## B与BL

-   .b与bl指令的作用是什么？ b与bl指令的作用：实现程序跳转，也就是调用子程序。

-   .b与bl指令的区别是什么？ b指令：简单的程序跳转，跳转到到目标标号处执行。bl指令：带链接程序跳转，也就是要带返回地址。在发生跳转前，将当前PC-4保存到R14中。也就是返回地址存在R14中，所以可以在子程序返回时只要MOV PC, LR即可。

-   .b与bl指令分别如何使用？使用时注意事项有哪些？举例说明。

    >   b .  ;死循环。"."--表示当前地址。
    >
    >   b reset  ;跳入reset处理程序
    >
    >   bl label  ;跳入label函数，同时将当前PC-4保存到R14中

## str指令
- STR指令的格式为：
```STR{条件}  源寄存器，<存储器地址>```
- STR指令用亍从源寄存器中将一个32位的字数据传送到存储器中。该指令在程序设计中比较常用，寻址方式灵活多样，使用方式可参考指令LDR。
- 指令示例：
    ```
    STR R0，[R1]，＃8  ；将R0中的字数据写入以R1为地址的存储器中，并将新地址R1＋8写入R1。
    STR R0，[R1，＃8]  ；将R0中的字数据写入以R1＋8为地址的存储器中。
    str     r1, [r0]  ；将r1寄存器的值，传送到地址值为r0的（存储器）内存中
    ```
- https://blog.csdn.net/assyiran/article/details/71440516
---
<br/>

## tst指令
- TST指令格式为：
```TST{条件}{P}  <op 1>, <op 2>```
- TST 来检查是否设置了特定的位。操作数 1 是要测试的数据字，操作数 2 是一个位掩码，TST指令将操作数1与操作数2做逻辑与运算，和ANDS的区别就是不保存结果。TST会改变CPSR的条件标志位。
- 这个指令通常与EQ，NE这些条件码来组合使用，但是使用过程中需要注意 ：与掩码逻辑与运算之后，全部测试位为0的时候，标志位Z = 1，此时EQ成立，反之则 Z = 0，NE成立。
---
<br/>

## cpsr_c
- ARM每种工作模式除R0~R15共16个寄存器外，还有第17个寄存器CPSR,叫做 当前程序状态寄存器，CPSR中一些位被用于标识各种状态，一些位被用于标识当前出于什么工作模式。
- ![avator](picture/cpsr.png)
- 其中cpsr_c代表的是这32位中的低8位，也就是控制位，当你看到有些程序里这样写 ```msr cpsr_c 0xd2```这样的语句时，就是在更改这8位的状态
---
<br/>

## LDMIA
- LDMIA R0! ,{R3-R9} ; 将R0指向的地址上连续空间的数据，保存到R3-R9当中，!表示R0值更新,IA后缀表示按WORD递增
---
<br/>

## SUBS Rn,Rn,#1
- 意思是 Rn 自身减 1 并设置标志位
---
<br/>

## adr r0， _start
- 将指定地址赋到r0中
---
<br/>

## ORR
- ORR指令的格式为： ORR{条件}{S}  目的寄存器，操作数1，操作数2
- ORR指令用于在两个操作数上进行逻辑或运算，并把结果放置到目的寄存器中。
- 操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。
- 操作数2为32位的掩码，如果在掩码中置了某一位1，则将这一位置1。未设置的掩码位保持不变。
---
<br/>

## MCR/MRC
- MCR指令将ARM处理器的寄存器中的数据传送到协处理器的寄存器中。如果协处理器不能成功地执行该操作，将产生未定义的指令异常中断。
- MRC指令将协处理器的寄存器中数值传送到ARM处理器的寄存器中。如果协处理器不能成功地执行该操作，将产生未定义的指令异常中断。
- ```MRC p2,5,r3,c5,c6``` 协处理器p2把c5和c6经过5操作的结果赋给r3
- ```MCR p6,0,r4,c5,c6``` 协处理器p6把r4执行0操作后将结果存放进c5
- ```MRC p3,9,r3,c5,c6,2``` 协处理器p3把c5和c6经过9操作（类型2）的结果赋给r3
- https://blog.csdn.net/wh8_2011/article/details/53183727
---
<br/>

## ldr
- ldr 加载指令： LDR{条件}  目的寄存器，<存储器地址>
    - LDR指令用亍从存储器中将一个32位的字数据传送到目的寄存器中。该指令通常用于从存储器中读取32位的字数据到通用寄存器，然后对数据进行处理。当程序计数器PC作为目的寄存器时，指令从存储器中读取的字数据被当作目的地址，从而可以实现程序流程的跳转。该指令在程序设计中比较常用，寻址方式灵活多样
    ```
        指令示例：
        LDR R0，[R1]         ；将存储器地址为R1的字数据读入寄存器R0。
        LDR R0，[R1，R2]  ；将存储器地址为R1+R2的字数据读入寄存器R0。
        LDR R0，[R1，＃8]   ；将存储器地址为R1+8的字数据读入寄存器R0。
        LDR R0，[R1，R2]！；将存储器地址为R1+R2的字数据读入寄存器R0,幵将新地址R1＋R2写入R1。
        LDR R0，[R1，＃8]！  ；将存储器地址为R1+8的字数据读入寄存器R0，幵将新地址R1＋8写入R1。 
        LDR R0，[R1]，R2  ；将存储器地址为R1的字数据读入寄存器R0，幵将新地址R1＋R2写入R1。
        LDR R0，[R1，R2，LSL＃2]！  ；将存储器地址为R1＋R2×4的字数据读入寄存器R0，并将新地址R1＋R2×4写入R1。
        LDR R0，[R1]，R2，LSL＃2  ；将存储器地址为R1的字数据读入寄存器R0，幵将新地址R1＋R2×4写入R1。”
    ```
- ldr伪指令
    - ARM指令集中，LDR通常都是作加载指令的，但是它也可以作伪指令。
    - LDR伪指令的形式是“LDR Rn,=expr”。
- http://blog.chinaunix.net/uid-28458801-id-4084264.html
---
<br/>

## EOR逻辑异或指令
- ```EOR{<cond>}{S}  <Rd>,<Rn>,<shifter_operand>```
    - 逻辑异或EOR（Exclusive OR）指令将寄存器<Rn>中的值和<shifter_operand>的值执行按位“异或”操作，并将执行结果存储到目的寄存器<Rd>中，同时根据指令的执行结果更新CPSR中相应的条件标志位。
---
<br/>

## LR(R14）寄存器
- lr(r14）的作用问题，这个lr一般来说有两个作用：
    1. 当使用bl或者blx跳转到子过程的时候，r14保存了返回地址，可以在调用过程结尾恢复。
    2. 异常中断发生时，这个异常模式特定的物理R14被设置成该异常模式将要返回的地址。

- 另外注意pc，在调试的时候显示的是当前指令地址，而用mov lr,pc的时候lr保存的是此指令向后数两条指令的地址，大家可以试一下用mov pc,pc，结果得到的是跳转两条指令，这个原因是由于arm的流水线造成的，预取两条指令的结果.
---
<br/>

## bic 
- BIC指令的格式为： ```BIC{条件}{S}  目的寄存器，操作数1，操作数2```
- BIC指令用于清除操作数1的某些位，并把结果放置到目的寄存器中。操作数1应是一个寄存器， 操作数2可以是一个寄存器、被移位的寄存器、或一个立即数。操作数2为32位的掩码，如果在 掩码中置了某一位1，则清除这一位。未设置的掩码位保持不变。
    ```
    bic r0,r0,#0x1f
    0x1f=11111b
    其含义：清除r0的bit[4:0]位。
    ```
---
<br/>

---
<br/>

---
<br/>

---
<br/>

---
<br/>

---
<br/>

---
<br/>