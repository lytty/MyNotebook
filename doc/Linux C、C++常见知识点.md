# Linux C、C++常见知识

## 1. [linux C 中的volatile使用](https://www.cnblogs.com/Neddy/archive/2012/02/02/2335343.html)

- 一个定义为`volatile`的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是`volatile`变量的几个例子： 
  1.  并行设备的硬件寄存器（如：状态寄存器） 
  2.  一个中断服务子程序中会访问到的非自动变量(`Non-automatic variables`) 
  3.  多线程应用中被几个任务共享的变量 

- volatile关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。

- volatile对应的变量可能在你的程序本身不知道的情况下发生改变，比如多线程的程序，共同访问的内存当中，多个程序都可以操纵这个变量 。你自己的程序，是无法判定合适这个变量会发生变化。还比如，他和一个外部设备的某个状态对应，当外部设备发生操作的时候，通过驱动程序和中断事件，系统改变了这个变量的数值，而你的程序并不知道。 对于volatile类型的变量，系统每次用到他的时候都是直接从对应的内存当中提取，而不会利用cache当中的原有数值，以适应它的未知何时会发生的变化，系统对这种变量的处理不会做优化——显然也是因为它的数值随时都可能变化的情况。

- 一般说来，volatile用在如下的几个地方： 

  1. 中断服务程序中修改的供其它程序检测的变量需要加volatile； 
  2. 多任务环境下各任务间共享的标志应该加volatile； 
  3. 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义； 

  另外，以上这几种情况经常还要同时考虑数据的完整性（相互关联的几个标志读了一半被打断了重写），在1中可以通过关中断来实现，2中可以禁止任务调度，3中则只能依靠硬件的良好设计了。 

- Linux 代码示例：

  ```c
  struct task_struct {
    	...
    	/* -1 unrunnable, 0 runnable, >0 stopped: */
    	volatile long			state;
      ...
  }
  
  ```

  